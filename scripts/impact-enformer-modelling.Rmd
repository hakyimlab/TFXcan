

```{r}
rm(list=ls())
cod
setwd('/projects/covid-ct/imlab/users/temi/projects/TFXcan/scripts/')

library(glue)
library(GenomicRanges)
library(reticulate)
library(R.utils)
library(data.table)
library(glmnet)
library(doMC)
library(ROCR)
library(Matrix)
library(reshape2)
```

```{r}
plots_dir <- '../plots'
```

Loading the data - 
```{r}
dt <- read.csv('/projects/covid-ct/imlab/users/temi/projects/TFXcan/output/train-test-data/data.csv')

X_train <- as.matrix(dt[, -c(1, 2)])
y_train <- as.matrix(dt[, 2])

dt_test <- read.csv('/projects/covid-ct/imlab/users/temi/projects/TFXcan/output/train-test-data/test-data.csv')

X_test <- as.matrix(dt_test[, -c(1, 2)])
y_test <- as.matrix(dt_test[, 2])
```

```{r}
X_train[1:5, 1:5]
```

The data is like

1 - CHIP:GATA3:T47D treated with 0.02% dimethyl sulfoxide for 1 hour
2 - CHIP:GATA3:SH-SY5Y
3 - CHIP:GATA3:MCF-7

I took all the cell lines for GATA3 and merged them into one. 

Then I took the predictions/tracks (see above) from Enformer of those regions and just put them row-wise

```{r}
TF <- 'GATA3'
cistrome_dir <- '/projects/covid-ct/imlab/data/cistrome/compressed'
hf_info <- data.table::fread(glue('{cistrome_dir}/human_factor_full_QC.txt'))
TF_DCID <- hf_info[hf_info$Factor == TF, ]
TF_DCID
```


Register a backend for parallelization
```{r}
# register a parallel backend 
registerDoMC(cores = 4)
```

Fit an elastic net model 
```{r}
ENet_fit <- cv.glmnet(x=X_train[complete.cases(X_train),], y=y_train[complete.cases(X_train)], family = "binomial", 
type.measure = "auc", alpha = 0.5, parallel=T, keep=T) #alpha: mixing term, lasso, 1-alpha ridge.
```

Some assessment plot
```{r fig.width=5, fig.height=5}
par(oma=c(1.0, 1.0, 3, 0.5) + 0.1)
plot(ENet_fit)
mtext('AUC across lambdas; aggByOverlaying; using GATA3 tracks only', side=3, line=3, cex=1.5)

dev.copy(png, glue('{plots_dir}/GATA3-only-aggByOverlaying.png'))
dev.off()
```

```{r}
min_error_index <- ENet_fit$index['min', ]
one_sd_index <- ENet_fit$index['1se', ]
# ENet_fit$glmnet.fit$beta
```

```{r}
dimensions <- ENet_fit$glmnet.fit$beta@Dim
coef_mat <- as.data.frame(summary(ENet_fit$glmnet.fit$beta))
colnames(coef_mat)

temp_mat <- matrix(data=NA, nrow=dimensions[1], ncol=dimensions[2])
for(i in 1:nrow(coef_mat)){
    temp_mat[coef_mat[i, 'i'], coef_mat[i, 'j']] <- coef_mat[i, 'x']
}

temp_mat[is.na(temp_mat)] <- 0
```

```{r}
df_beta <- cbind(temp_mat[, min_error_index], temp_mat[, one_sd_index])
df_beta_labels <- c('For lambda with minimum mean cv error', 'For largest lambda with 1 s.e within the mininum error')
motif_center <- 448
```

```{r}
layout(matrix(c(1:2), nrow = 2, ncol = 1, byrow = T), heights = c(4.0, 4.0))
# par(mar=rep(0.01, 4))
# plot.new()
# legend('center', legend=c('theoretical', 'regression'), col=c('black', 'red'), lty=1)
#par(mfrow=c(2,2), oma = c(3.5,3.5,1,1) + 0.1, mar = c(3,1.5,1,1) + 0.1,)
par(mar=c(2.5,2.5,2,2) + 0.1, oma=c(1.0, 1.0, 3.5, 0.5) + 0.1)

for(i in 1:ncol(df_beta)){
    plot(df_beta[, i], type='l', xlab='bins', xaxt='n', ylab='coefficients', main=df_beta_labels[i])
    axis(1, at=seq(1, 5310))
    #abline(v=motif_center, col='red')
    mtext('bins', side=1, outer=T, cex=1.2)
    mtext('coefficients', side=2, outer=T, cex=1)
}

mtext('Distribution of coefficients across bins; aggByOverlaying; GATA3 only', side=3, outer=T, cex=1.5)

dev.copy(png, glue('{plots_dir}/spread-of-coefficients-GATA3-only-aggByOverlaying.png'))
dev.off()

```


```{r}
dt_melt <- reshape2::melt(temp_mat)
```

```{r}
ggplot2::ggplot(dt_melt, aes(Var1, Var2)) + geom_tile(aes(fill = value)) + scale_fill_gradient(low = "white", high = "red")
```
```{r}
heatmap(temp_mat, Rowv=NA, Colv=NA, scale='column')
```



```{r}
image(1:ncol(coef_mat), 1:nrow(coef_mat), t(m), col=terrain.colors(60), axes=F)
axis(1, 1:ncol(coef_mat), colnames(coef_mat))
axis(2, 1:nrow(coef_mat), rownames(coef_mat))
for (x in 1:ncol(coef_mat))
  for (y in 1:nrow(coef_mat))
    text(x, y, coef_mat[y,x])
```

```{r}
heatmap(as.matrix(coef_mat@x))
```

```{r}
#ENet_fit$glmnet.fit$beta[, min_error_index] |> plot()

plot(ENet_fit$glmnet.fit$beta[, min_error_index], type='l', xlab='bins', ylab='coefficients')
```

```{r}
plot(ENet_fit$glmnet.fit$beta[, one_sd_index], type='l', xlab='bins', ylab='coefficients')
```



Prediction/AUC on the training 
glmnet has an in-built function for this but I prefer to use ROCR's
```{r}
train_predictions <- predict(ENet_fit, newx=X_train, type='response')
test_predictions <- predict(ENet_fit, newx=X_test, type='response')

train_pred <- ROCR::prediction(train_predictions, y_train)
test_pred <- ROCR::prediction(test_predictions, y_test)

train_perf <- ROCR::performance(train_pred, "tpr", "fpr")
test_perf <- ROCR::performance(test_pred, "tpr", "fpr")

train_perf_pr <- ROCR::performance(train_pred, "prec", "rec")
test_perf_pr <- ROCR::performance(test_pred, "prec", "rec")
```

```{r}
plt_perf <- c(train_perf, test_perf, train_perf_pr, test_perf_pr)
names_plt_perf <- c('training roc', 'test roc','training PR', 'test PR')
```

`pred` is a prediction instance - can assess with `@`

```{r}

layout(matrix(c(1:4), nrow = 2, ncol = 2, byrow = T), heights = c(4.0, 4.0))
# par(mar=rep(0.01, 4))
# plot.new()
# legend('center', legend=c('theoretical', 'regression'), col=c('black', 'red'), lty=1)
#par(mfrow=c(2,2), oma = c(3.5,3.5,1,1) + 0.1, mar = c(3,1.5,1,1) + 0.1,)
par(mar=c(2.5,2.5,2,2) + 0.1, oma=c(3.0, 3.0, 0.5, 0.5) + 0.1)

#performance(pred,"auc") # shows calculated AUC for model

for(i in 1:length(plt_perf)){

    plot(plt_perf[[i]], colorize = F, col="black", main=names_plt_perf[[i]], frame.plot=F) # plot ROC curve
    if(i %in% c(1:2)){
        lines(c(0,1),c(0,1),col = "gray", lty = 4)
        mtext('Hello', 4, 3, outer=T) 
    }
}

```

```{r}
dev.off()
```

```{r}
assess.glmnet(ENet_fit, newx = X_test, newy = y_test)
```

Looks like the precision-recall curve is not so good. 

Here, I check the distribution of the coefficients
```{r}
hist(coef(ENet_fit) |> as.numeric(), main='Distribution of coefficients', xlab='coefficients')
```

\newpage

# Models built based on aggregating by the mean

```{r}
ind <- 'HG00479'
```

```{r}
train_data <- read.csv(glue('/projects/covid-ct/imlab/users/temi/projects/TFXcan/output/train-test-data/train_aggByMean_{ind}.csv'))

X_train <- as.matrix(train_data[, -c(1)])
y_train <- as.matrix(train_data[, 1])

test_data <- read.csv(glue('/projects/covid-ct/imlab/users/temi/projects/TFXcan/output/train-test-data/test_aggByMean_{ind}.csv'))

X_test <- as.matrix(test_data[, -c(1)])
y_test <- as.matrix(test_data[, 1])
```

```{r}
# register a parallel backend 
registerDoMC(cores = 4)
```
```{r}
enet_fit_aggByMean <- cv.glmnet(x=X_train[complete.cases(X_train),], y=y_train[complete.cases(X_train)], family = "binomial", 
type.measure = "auc", alpha = 0.5, parallel=T, keep=T)
```

```{r}
par(oma=c(1.0, 1.0, 3, 0.5) + 0.1)

enet_fit_aggByMean |> plot()
mtext('AUC across lambdas; aggByMean; All tracks except GATA3', side=3, line=3, cex=1.5)

# dev.copy(png, glue('{plots_dir}/except-GATA3-aggByMean.png'))
# dev.off()
```

```{r}
min_error_index <- enet_fit_aggByMean$index['min', ]
one_sd_index <- enet_fit_aggByMean$index['1se', ]
# ENet_fit$glmnet.fit$beta
```

```{r}
dimensions <- enet_fit_aggByMean$glmnet.fit$beta@Dim
coef_mat <- as.data.frame(summary(enet_fit_aggByMean$glmnet.fit$beta))
cat(colnames(coef_mat))

temp_mat <- matrix(data=NA, nrow=dimensions[1], ncol=dimensions[2])
for(i in 1:nrow(coef_mat)){
    temp_mat[coef_mat[i, 'i'], coef_mat[i, 'j']] <- coef_mat[i, 'x']
}

temp_mat[is.na(temp_mat)] <- 0
```

```{r}
df_beta <- cbind(temp_mat[, min_error_index], temp_mat[, one_sd_index])
df_beta_labels <- c('For lambda with minimum mean cv error', 'For largest lambda with 1 s.e within the mininum error')
```

```{r}
#png(glue('{plots_dir}/spread-of-coefficients-except-GATA3-aggByMean.png'))

layout(matrix(c(1:2), nrow = 2, ncol = 1, byrow = T))
# par(mar=rep(0.01, 4))
# plot.new()
# legend('center', legend=c('theoretical', 'regression'), col=c('black', 'red'), lty=1)
#par(mfrow=c(2,2), oma = c(3.5,3.5,1,1) + 0.1, mar = c(3,1.5,1,1) + 0.1,)
par(mar=c(2.5,2.5,2,2) + 0.1, oma=c(1.0, 1.0, 3.5, 0.5) + 0.1)

for(i in 1:ncol(df_beta)){
    plot(df_beta[, i], type='l', xlab='bins', xaxt='n', ylab='coefficients', main=df_beta_labels[i])
    axis(1, at=seq(1, 5310))
    #abline(v=motif_center, col='red')
    mtext('tracks', side=1, outer=T, cex=1.2)
    mtext('coefficients', side=2, outer=T, cex=1.2)
}

mtext('Distribution of coefficients across tracks; aggByMean; except GATA3', side=3, outer=T, cex=1.3)

# dev.copy(png, glue('{plots_dir}/spread-of-coefficients.png'))
#dev.off()

```

```{r}
dev.print(png, glue('{plots_dir}/spread-of-coefficients-except-GATA3-aggByMean.png'))
#dev.off()

```

What track gives the largest coefficient?
```{r}
which.max(df_beta[, 1])
```

```{r}
max(df_beta[, 1])
```

# Using the motif bin

```{r}
ind <- 'HG00479'
```

```{r}
train_data <- read.csv(glue('/projects/covid-ct/imlab/users/temi/projects/TFXcan/output/train-test-data/train_aggByCenter_{ind}.csv'))

X_train <- as.matrix(train_data[, -c(1)])
y_train <- as.matrix(train_data[, 1])

test_data <- read.csv(glue('/projects/covid-ct/imlab/users/temi/projects/TFXcan/output/train-test-data/test_aggByCenter_{ind}.csv'))

X_test <- as.matrix(test_data[, -c(1)])
y_test <- as.matrix(test_data[, 1])
```

```{r}
# register a parallel backend 
registerDoMC(cores = 4)
```
```{r}
enet_fit_aggByCenter <- cv.glmnet(x=X_train[complete.cases(X_train),], y=y_train[complete.cases(X_train)], family = "binomial", 
type.measure = "auc", alpha = 0.5, parallel=T, keep=T)
```

```{r}
enet_fit_aggByCenter |> plot()
mtext('AUC across lambdas; aggByCenter; All tracks except GATA3', side=3, line=3, cex=1.5)

# dev.copy(png, glue('{plots_dir}/except-GATA3-aggByMean.png'))
# dev.off()
```

```{r}
min_error_index <- enet_fit_aggByCenter$index['min', ]
one_sd_index <- enet_fit_aggByCenter$index['1se', ]
# ENet_fit$glmnet.fit$beta
```

```{r}
dimensions <- enet_fit_aggByCenter$glmnet.fit$beta@Dim
coef_mat <- as.data.frame(summary(enet_fit_aggByCenter$glmnet.fit$beta))
cat(colnames(coef_mat))

temp_mat <- matrix(data=NA, nrow=dimensions[1], ncol=dimensions[2])
for(i in 1:nrow(coef_mat)){
    temp_mat[coef_mat[i, 'i'], coef_mat[i, 'j']] <- coef_mat[i, 'x']
}

temp_mat[is.na(temp_mat)] <- 0
```

```{r}
df_beta <- cbind(temp_mat[, min_error_index], temp_mat[, one_sd_index])
df_beta_labels <- c('For lambda with minimum mean cv error', 'For largest lambda with 1 s.e within the mininum error')
```

```{r}
#png(glue('{plots_dir}/spread-of-coefficients-except-GATA3-aggByMean.png'))

layout(matrix(c(1:2), nrow = 2, ncol = 1, byrow = T))
# par(mar=rep(0.01, 4))
# plot.new()
# legend('center', legend=c('theoretical', 'regression'), col=c('black', 'red'), lty=1)
#par(mfrow=c(2,2), oma = c(3.5,3.5,1,1) + 0.1, mar = c(3,1.5,1,1) + 0.1,)
par(mar=c(2.5,2.5,2,2) + 0.1, oma=c(1.0, 1.0, 3.5, 0.5) + 0.1)

for(i in 1:ncol(df_beta)){
    plot(df_beta[, i], type='l', xlab='bins', xaxt='n', ylab='coefficients', main=df_beta_labels[i])
    axis(1, at=seq(1, 5310))
    #abline(v=motif_center, col='red')
    mtext('tracks', side=1, outer=T, cex=1.2)
    mtext('coefficients', side=2, outer=T, cex=1.2)
}

mtext('Distribution of coefficients across tracks; aggByCenter; except GATA3', side=3, outer=T, cex=1.3)

# dev.copy(png, glue('{plots_dir}/spread-of-coefficients.png'))
#dev.off()

```

```{r}
dev.print(png, glue('{plots_dir}/spread-of-coefficients-except-GATA3-aggByMean.png'))
#dev.off()

```

What track gives the largest coefficient?
```{r}
which.max(df_beta[, 1])
```

```{r}
max(df_beta[, 1])
```