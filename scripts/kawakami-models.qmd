---
title: "Building models from Kawakami's TF ChIP seq data"
author: "Temi"
date: 'Wednesday September 28 2022'
format: 
  pdf: 
    toc: true
    number-sections: true
    code-line-numbers: true
---

```{r}
rm(list=ls())
setwd('/projects/covid-ct/imlab/users/temi/projects/TFXcan/scripts/')

library(glue)
library(GenomicRanges)
library(reticulate)
library(R.utils)
library(data.table)
library(glmnet)
library(doMC)
library(ROCR)
library(Matrix)
library(reshape2)
library(tidyverse)
library(foreach)
library(doParallel)
```

```{r}
plots_dir <- '../plots'
data_dir <- '../enformer_predictions/train-test-val'
TF <- 'FOXA1'
cell_line <- 'LuCaP'
```

For plotting, I need to load in the enformer annotations
```{r}
enformer_annotations <- data.table::fread('../info-files/enformer_tracks_annotated-resaved.txt')
enformer_annotations <- enformer_annotations[!is.na(enformer_annotations$assay), ]
```

```{r}
test_models <- function(model, X_test_set, y_test_set){
    features <- model$glmnet.fit$beta |> rownames()
    X_test_set <- X_test_set[, features]
    assess.glmnet(model, newx = X_test_set, newy = y_test_set) |> unlist()
}
```


Aggregating by the center

Loading the data - 
```{r}
dt_center <- data.table::fread(glue('{data_dir}/aggByCenter_{TF}_{cell_line}.csv'))
dt_center_0 <- dt_center[dt_center$class == 0, ]
dt_center_1 <- dt_center[dt_center$class == 1, ]

dt_center$class |> table()
```

```{r}
set.seed(2022)
train_indices_0 <- sample(x=1:nrow(dt_center_0), size=1000, replace=F)
train_indices_1 <- sample(x=1:nrow(dt_center_1), size=1000, replace=F)

train_data <- rbind(dt_center_0[train_indices_0, ], dt_center_1[train_indices_1, ])
test_data <- rbind(dt_center_0[-train_indices_0, ], dt_center_1[-train_indices_1, ])
```

```{r}
dim(train_data)
dim(test_data)
```

```{r}
X_train <- train_data[, -c(1)] |> as.matrix()
y_train <- train_data[, 1] |> as.matrix()

X_test <- test_data[, -c(1)] |> as.matrix()
y_test <- test_data[, 1] |> as.matrix()
```

Register a backend for parallelization
```{r}
# register a parallel backend 
# registerDoMC(cores = 4)
```

Fit an elastic net model 
```{r}
# enet_center <- glmnet::cv.glmnet(x=X_train[complete.cases(X_train),], y=y_train[complete.cases(X_train)], family = "binomial", 
# type.measure = "auc", alpha = 0.5, parallel=T, keep=T) #alpha: mixing term, lasso, 1-alpha ridge.
```


```{r}

build_models <- function(aggMList, dt_dir=data_dir){

    enet_models <- list()
    enet_performance <- list()
    enet_metrics <- list()

    for(i in 1:length(aggMList)){

        aggM <- aggMList[i]

        dt_center <- data.table::fread(glue('{dt_dir}/{aggM}_{TF}_{cell_line}.csv'))
        dt_center_0 <- dt_center[dt_center$class == 0, ]
        dt_center_1 <- dt_center[dt_center$class == 1, ]

        set.seed(2022)
        train_indices_0 <- sample(x=1:nrow(dt_center_0), size=1000, replace=F)
        train_indices_1 <- sample(x=1:nrow(dt_center_1), size=1000, replace=F)

        train_data <- rbind(dt_center_0[train_indices_0, ], dt_center_1[train_indices_1, ])
        test_data <- rbind(dt_center_0[-train_indices_0, ], dt_center_1[-train_indices_1, ])

        X_train <- train_data[, -c(1)] |> as.matrix()
        y_train <- train_data[, 1] |> as.matrix()

        X_test <- test_data[, -c(1)] |> as.matrix()
        y_test <- test_data[, 1] |> as.matrix()

        enet_models[[i]] <- glmnet::cv.glmnet(x=X_train[complete.cases(X_train),], y=y_train[complete.cases(X_train)], family = "binomial", type.measure = "auc", alpha = 0.5, parallel=T, keep=T)

        # performance
        pred_probs <- predict(enet_models[[i]], X_test, type='response')
        pred_instance <- ROCR::prediction(pred_probs, y_test)

        test_auc_roc <- ROCR::performance(pred_instance, 'tpr', 'fpr')
        test_prec_rec <- ROCR::performance(pred_instance, "prec", "rec")
        enet_performance[[i]] <- list(auc=test_auc_roc, auprc=test_prec_rec)

        auc_value <- glmnet::assess.glmnet(enet_models[[i]], X_test, y_test)$auc[[1]]
        #prauc_value <- ROCR::performance(pred_instance, "prec", "rec")
        enet_metrics[[i]] <- list(auc_values=auc_value)

    }

    names(enet_models) <- aggMList
    names(enet_performance) <- aggMList
    names(enet_metrics) <- aggMList

    return(list(models=enet_models, performance=enet_performance, auc_values=enet_metrics))  

}
```

```{r}
aggMethods <- c('aggByCenter', 'aggByMean', 'aggByUpstream', 'aggByDownstream', 'aggByUpstreamDownstream')
enet_experiment <- build_models(aggMethods)
```

```{r}
colors_ <- c('black', 'red', 'green', 'blue', 'grey')
```


```{r}

layout(matrix(c(1, 2), nrow=1, ncol=2))

plot(enet_experiment$performance[[aggMethods[1]]]$auc, col=colors_[1], main='ROC curve | using all 5313 tracks from ENFORMER')
for(i in 2:length(aggMethods)){
    plot(enet_experiment$performance[[aggMethods[i]]]$auc, col=colors_[i], add=T)
}
legend('center', legend=paste0(aggMethods, ' (', round(enet_experiment$auc_values |> unlist(), 3) |> unname(), ')'), col=colors_, lty=1)

plot(enet_experiment$performance[[aggMethods[1]]]$auprc, col=colors_[1], main='Precision Recall curve | using all 5313 tracks from ENFORMER')
for(i in 2:length(aggMethods)){
    print(aggMethods[i])
    plot(enet_experiment$performance[[aggMethods[i]]]$auprc, col=colors_[i], add=T)
}
legend(x=0.2, y=0.6, legend=aggMethods, col=colors_, lty=1)
```

```{r}

```


```{r}
# plot(enet_experiment$performance[[aggMethods[1]]]$auc, col=colors_[1])
# plot(enet_experiment$performance[[aggMethods[2]]]$auc, col=colors_[2], add=T)
# plot(enet_experiment$performance[[aggMethods[3]]]$auc, col=colors_[3], add=T)
# plot(enet_experiment$performance[[aggMethods[4]]]$auc, col=colors_[4], add=T)
# plot(enet_experiment$performance[[aggMethods[5]]]$auc, col=colors_[5], add=T)
```




Exploring the aggByCenter model
```{r}
dimensions <- enet_experiment$models$aggByCenter$glmnet.fit$beta@Dim
coef_mat <- as.data.frame(summary(enet_experiment$models$aggByCenter$glmnet.fit$beta))
colnames(coef_mat)

temp_mat <- matrix(data=NA, nrow=dimensions[1], ncol=dimensions[2])
for(i in 1:nrow(coef_mat)){
    temp_mat[coef_mat[i, 'i'], coef_mat[i, 'j']] <- coef_mat[i, 'x']
}

temp_mat[is.na(temp_mat)] <- 0
```

```{r}
min_error_index <- enet_experiment$models$aggByCenter$index['min', ]
one_sd_index <- enet_experiment$models$aggByCenter$index['1se', ]

df_beta <- cbind(temp_mat[, min_error_index], temp_mat[, one_sd_index]) |> as.data.frame()
df_beta_labels <- c('For lambda with minimum mean cv error', 'For largest lambda with 1 s.e within the mininum error')
motif_center <- 448
```

```{r}
df_beta$feature_names <- paste('f', 0:(nrow(df_beta)-1), sep='_')
```

```{r}
feature_coefficients <- merge(df_beta, enformer_annotations, by='feature_names', all=T)

feature_coefficients$sort_by <- sapply(str_split(feature_coefficients$feature_names, pattern = '_'), getElement, 2) |> as.numeric()

feature_coefficients <- feature_coefficients[order(feature_coefficients$sort_by), ]
```

```{r}
plot(feature_coefficients[, 'V1'], type='l', xlab='tracks', xaxt='n', ylab='coefficients', main='Coefficients across predicted ENFORMER tracks')
axis(1, at=seq(1, 5313), col=factor(feature_coefficients$mark))
# #abline(v=motif_center, col='red')
# mtext('tracks', side=1, outer=T, cex=1.2)
# mtext('coefficients', side=2, outer=T, cex=1.2)

# mtext('Distribution of coefficients across tracks; aggByMean; except GATA3', side=3, outer=T, cex=1.3)
```

```{r}
library(RColorBrewer)
useColors <- RColorBrewer::brewer.pal(n=8, name='Dark2')
```

```{r}
feature_coefficients_split <- split(feature_coefficients, feature_coefficients$assay)

ylimits <- c(min(feature_coefficients[, 'V1']), max(feature_coefficients[, 'V1']))
# |> row.names() |> as.numeric()
plot(x=feature_coefficients_split[[1]]$sort_by , y=feature_coefficients_split[[1]][, 'V1'], type='l', col=useColors[1], xlim=c(1, nrow(feature_coefficients)), ylim=ylimits, xaxt='n', main='Coefficients across 5313 ENFORMER tracks', xlab='ENFORMER tracks', ylab='coefficients')

for(j in 2:length(feature_coefficients_split)){
    lines(x=feature_coefficients_split[[j]]$sort_by, y=feature_coefficients_split[[j]][, 'V1'], col=useColors[j])
}

axis(1, at=seq(1, nrow(feature_coefficients)))

legend('bottomleft', legend=names(feature_coefficients_split), col=useColors[1:length(feature_coefficients_split)], lty=1, bty='n')

```

```{r}
nfcsplit <- names(feature_coefficients_split)
```

```{r}
usage_metric <- lapply(feature_coefficients_split, function(each_cat){
    usage <- ifelse(each_cat$V1 > 0, 1, 0)
    return( paste(sum(usage), 'of', length(usage), sep=' '))
})  |> unlist()
usage_metric
```
```{r}
usage_heights <- lapply(feature_coefficients_split, function(each_cat){
    usage <- ifelse(each_cat$V1 > 0, 1, 0)
    return((sum(usage) / length(usage)) * 100)
}) |> unlist()

bplot <- barplot(usage_heights, main='Percent usage of tracks per category', ylab='% of tracks with non-zero coefficients', xlab='category', ylim=c(0, 35), col="#69b3a2")

text(x=bplot, y=usage_heights + 1, pos = 3, label = usage_metric, cex = 1, col = "red")
```

```{r}
coef_details <- feature_coefficients[abs(feature_coefficients$V1) > 0, c('V1', 'assay', 'detail')]
```

```{r}
coef_details[grepl('FOXA1', coef_details$detail), ]
```

# Doing all different combinations

```{r}
build_save_list_model <- function(){

    # this function by default uses whatever X_train and y_train is in the environment

    cl <- makeCluster(12)
    registerDoParallel(cl)
    print(getDoParName())

    assays_dt <- get('assays_dt', .GlobalEnv)
    enformer_annotations <- get('enformer_annotations', .GlobalEnv)
    X_train <- get('X_train', .GlobalEnv)
    y_train <- get('y_train', .GlobalEnv)

    enet_models_list <- foreach(i = 1:nrow(assays_dt)) %dopar% {
        cat('Currently on', i, '\n')
        # select the categories
        track_categories <- assays_dt[i, ][!is.na(assays_dt[i, ])]
        selected_tracks <- enformer_annotations$feature_names[enformer_annotations$assay %in% track_categories]
        X_train_selected <- X_train[, colnames(X_train) %in% selected_tracks]
        #X_test_selected <- X_test[, colnames(X_test) %in% selected_tracks]

        enet_fit_selected <- glmnet::cv.glmnet(x=X_train_selected[complete.cases(X_train_selected),], y=y_train[complete.cases(X_train_selected)], family = "binomial", type.measure = "auc", alpha = 0.5, parallel=T, keep=T)

        enet_fit_selected
    }

    stopCluster(cl)
    return(enet_models_list)
}
```

```{r}
# create the assays_dt file

assays <- enformer_annotations$assay |> unique()
z_list <- list()
for(i in 1:length(assays)){
    z <- combn(assays, i)
    z_list[[i]] <- t(z) |> as.data.frame()
}

assays_dt <- plyr::rbind.fill(z_list)
```

```{r}
aggMethods <- c('aggByCenter', 'aggByMean', 'aggByUpstream', 'aggByDownstream', 'aggByUpstreamDownstream')
```

```{r}

test_data_list <- list()
models_list <- list()

for(aggM in aggMethods){

    dt_center <- data.table::fread(glue('{data_dir}/{aggM}_{TF}_{cell_line}.csv'))
    feature_names <- c('class', paste('f_', 0:(ncol(dt_center) - 2), sep=''))
    setnames(dt_center, feature_names)
    dt_center_0 <- dt_center[dt_center$class == 0, ]
    dt_center_1 <- dt_center[dt_center$class == 1, ]

    train_indices_0 <- sample(x=1:nrow(dt_center_0), size=1000, replace=F)
    train_indices_1 <- sample(x=1:nrow(dt_center_1), size=1000, replace=F)

    train_data <- rbind(dt_center_0[train_indices_0, ], dt_center_1[train_indices_1, ])
    test_data <- rbind(dt_center_0[-train_indices_0, ], dt_center_1[-train_indices_1, ])

    X_train <- train_data[, -c(1)] |> as.matrix()
    y_train <- train_data[, 1] |> as.matrix()

    X_test <- test_data[, -c(1)] |> as.matrix()
    y_test <- test_data[, 1] |> as.matrix()

    # save the test data to be used after modelling
    test_data_list[[aggM]] <- cbind(y_test, X_test)

    # train the model by aggM
    models_list[[aggM]] <- build_save_list_model()

}



```

```{r}
models_dir <- '/projects/covid-ct/imlab/users/temi/projects/TFXcan/models'
saveRDS(list(models=models_list, test_data=test_data_list), file=glue('{models_dir}/kawakami_small_models.RData'))
```






Session Information
```{r}
sessionInfo()
```






