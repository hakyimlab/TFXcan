---
title: "IMPACT vs. PMIntersect (Peak Motif Intersect) approaches to defining bound and unbound regions"
author: "Temi"
date: 'Wednesday Dec 14 2022'
format: 
  pdf: 
    toc: true
    number-sections: true
    code-line-numbers: true
---


```{r}
library(glue)
library(rjson)
library(data.table)
library(GenomicRanges)
library(parallel)
library(tidyverse)
```

```{r}
project_dir <- '/lus/theta-fs0/projects/covid-ct/imlab/users/temi/projects/TFXcan/impact_pipeline'
#setwd(project_dir)
```

```{r}
output_dir <- glue('{project_dir}/explore_impact')
id <- 'kawakami'
TF <- 'FOXA1'
cell_line <- 'LuCaP'
homer_dir <- glue('~/miniconda3/envs/homer-env/share/homer')
common_dir <- glue('{project_dir}/processed_data/impact_files/common_files/{TF}')
```

Directories and e.t.c.
```{r}
chip_file <- glue('{project_dir}/processed_data/impact_files/kawakami-human/bedtools-intersected-regions/FOXA1_intersected_files.bed')
chip_dt <- data.table::fread(chip_file, select=c(1:5))
chip_dt[1:5, ]
```
Select 200 peaks to test with (These are randomly selected peaks)
```{r}
set.seed(2022)
chip_dt <- chip_dt[sample(1:nrow(chip_dt), 200, replace=F), ]
nrow(chip_dt)
```

```{r}
chip_granges <- with(chip_dt, GenomicRanges::GRanges(chrom, IRanges(start, end), strand='*'))
chip_granges
```

Next, make the granges appropriate for impact

```{r}
chip_bed <- cbind(as.character(seqnames(chip_granges)), start(chip_granges), end(chip_granges), paste0("peak", seq(1,length(chip_granges),1)), 0, "+")
write.table(chip_bed, glue("{output_dir}/{id}_{TF}_{cell_line}_train_df.txt"), sep = "\t", quote = F, row.names = FALSE, col.names = FALSE)
chip_bed[1:5, ]
```

```{r}
cmd <- glue('perl {homer_dir}/bin/findMotifsGenome.pl {output_dir}/{id}_{TF}_{cell_line}_train_df.txt {homer_dir}/data/genomes/hg19 {output_dir}/homer_output/ -size given -find {common_dir}/{TF}_{cell_line}.motif > {output_dir}/{id}_{TF}_{cell_line}_findinstances.txt')
system(cmd)
```

```{r}
cmd <- glue('perl {homer_dir}/bin/annotatePeaks.pl {output_dir}/{id}_{TF}_{cell_line}_train_df.txt {homer_dir}/data/genomes/hg19 -size given -m {common_dir}/{TF}_{cell_line}.motif > {output_dir}/annotated_{id}_{TF}_{cell_line}_findinstances.txt')
system(cmd)
```

```{r}
data.table::fread(glue('{output_dir}/annotated_{id}_{TF}_{cell_line}_findinstances.txt'))
```


#### Positive regions are defined this way

```{r}
motif_instances <- read.table(glue('{output_dir}/{id}_{TF}_{cell_line}_findinstances.txt'), sep = "\t", header = T, stringsAsFactors = FALSE)
motif_instances
```

```{r}
chip_regions <- read.table(glue('{output_dir}/{id}_{TF}_{cell_line}_train_df.txt'), sep='\t', header=F, stringsAsFactors=F) 
motif_library <- read.table(glue('{common_dir}/{TF}_{cell_line}_motif_threshold_info.txt'), sep = "\t", header = F, stringsAsFactors = FALSE)

colnames(chip_regions) <- c("seqnames","starts","ends","names","scores","strands")
#select ChIP peaks with a matching motif under them.
chip_regions_full <- chip_regions
m <- match(chip_regions[,4], motif_instances[,1]) # what chips are in motifs data?
chip_regions <- chip_regions_full[which(is.na(m) == F),]
```

```{r}
chip_regions_newpeaks <- matrix(0,nrow(chip_regions),6) #dummy var number of rows 

for (i in 1:nrow(chip_regions)){
    print(paste0("row ", i, " of ", nrow(chip_regions)))
    w <- which(motif_instances$PositionID == chip_regions[i,4]) #match peakID, gauranteed to have a match 

    #only choose 1 motif, take the one with the top score
    w1 <- w[match(max(motif_instances$MotifScore[w]), motif_instances$MotifScore[w])]

    if (motif_instances$Strand[w1] == "+"){
        centerpeak <- motif_instances$Offset[w1] + floor(0.5*(nchar(motif_instances$Sequence[w1]))) #this is relative to start 
    }else{
        centerpeak <- motif_instances$Offset[w1] - floor(0.5*(nchar(motif_instances$Sequence[w1])))
    }
    newstart <- chip_regions$starts[i]+centerpeak #previous version of impact -windowsize/2 #establish left bound of peaks
    newend <- newstart + 1 #previous version of impact +windowsize #establish right bound of peaks 
    chip_regions_newpeaks[i,1] <- as.character(chip_regions$seqnames[i])
    chip_regions_newpeaks[i,2] <- newstart
    chip_regions_newpeaks[i,3] <- newend
    chip_regions_newpeaks[i,4] <- as.character(chip_regions$names[i]) #preserve old information
    chip_regions_newpeaks[i,5] <- as.character(chip_regions$scores[i])
    chip_regions_newpeaks[i,6] <- as.character(chip_regions$strands[i])
}

write.table(chip_regions_newpeaks, glue("{output_dir}/{id}_{TF}_{cell_line}_train_df_newpeaks.txt"), sep = "\t", quote = F, row.names = FALSE, col.names = FALSE)
chip_regions_newpeaks
```

```{r}
chip_regions_newpeaks <- read.table(glue('{output_dir}/{id}_{TF}_{cell_line}_train_df_newpeaks.txt'), sep = "\t", header = F, stringsAsFactors = FALSE)

chip_regions_newpeaks_realdf <- data.frame(seqnames=chip_regions_newpeaks[,1],
                                    starts=as.numeric(chip_regions_newpeaks[,2]),
                                    ends=as.numeric(chip_regions_newpeaks[,3]),
                                    names=chip_regions_newpeaks[,4],
                                    scores=0,
                                    strands="+")

set.seed(2022)
s <- sample(seq(1,nrow(chip_regions_newpeaks_realdf),1), nrow(chip_regions_newpeaks_realdf),replace = F)
s
```


```{r}
chip_regions_newpeaks_realdf <- chip_regions_newpeaks_realdf[s,]
#put training and test together! 
#use partition function later to make it easier to sample many times! 
train_test_peaks <- unique(chip_regions_newpeaks_realdf)
colnames(train_test_peaks) <- c("seqnames","starts","ends","names","scores","strands")

#clean up 
if (length(which(train_test_peaks$start < 0)) > 0){
    train_test_peaks$start[which(train_test_peaks$start < 0)] <- 0
}

t <- train_test_peaks[,3]-train_test_peaks[,2]
w <- which(t %% 2 != 0) #odd
if (length(w) > 0){
    train_test_peaks[w,3] <- train_test_peaks[w,3] + 1
}

w1 <- which(train_test_peaks$chr == "chrM")
w2 <- which(nchar(train_test_peaks$chr) > 5)
if (length(c(w1,w2)) > 0){
    train_test_peaks <- train_test_peaks[-c(w1,w2),]
}

write.table(train_test_peaks, glue("{output_dir}/{id}_{TF}_{cell_line}_train_test_positive_bed.txt"), sep = "\t", quote = F, row.names = FALSE, col.names = FALSE)
train_test_peaks
```


#### Negative sets are defined this way

```{r}
train_df_newpeaks <- read.table(glue("{output_dir}/{id}_{TF}_{cell_line}_train_df_newpeaks.txt"), sep = "\t", header = F, stringsAsFactors = FALSE)

MotifThreshold <- read.table(glue("{common_dir}/{TF}_{cell_line}_motif_threshold_info.txt"), sep = "\t", header = F, stringsAsFactors = FALSE)
```

```{r}
motifs <- MotifThreshold[1,1]
instscan <- read.table(glue("{common_dir}/{TF}_{cell_line}_scanMotifsGenomewide_sort_15000.txt"), sep = "\t", header = F, stringsAsFactors = FALSE)
instscan[1:5, ]
```

```{r}
instscan <- instscan[order(instscan[,6], decreasing = T), ]   
train_df <- read.table(glue("{output_dir}/{id}_{TF}_{cell_line}_train_df.txt"), sep = "\t", header = F, stringsAsFactors = FALSE) 
colnames(train_df) <- c('chr','start','end','id','score','strand') #score may be number of reads
Granges <- with(train_df, GRanges(chr, IRanges(start,end), strand, score, id = id))
assign(paste0(motifs,"_Granges"),Granges)
```

```{r}
allinstscan <- instscan
sapply_instscan <- sapply(1:nrow(allinstscan), function(x) strsplit(allinstscan[x,1], "-")[[1]][1])
allinstscan[,1] <- sapply_instscan
allinstscan[,6] <- allinstscan[,6]/MotifThreshold[1,2]
allinstscan[1:5, ]
```

```{r}
w <- which(allinstscan[,6] < 1) 
if(length(w)>0){allinstscan <- allinstscan[-w,]}

motifmatrix <- matrix(0,nrow(MotifThreshold),3)
motifmatrix[,1] <- motifs 
motifmatrix[,2] <- motifs
motifmatrix[,3] <- paste0(motifs,"_Granges")
motifmatrix
```

```{r}
print(paste0("working on ",motifmatrix[1,1]))
w_mcp <- which(train_df_newpeaks[,5] == motifmatrix[1,2]) #motifcentered peaks
motifcentered_specificTF <- train_df_newpeaks[w_mcp,]
colnames(motifcentered_specificTF) <- c('chr','start','end','id','score','strand') 
Granges_obj_mc <- with(motifcentered_specificTF, GRanges(chr, IRanges(start,end), strand, score, id = id))
Granges_obj_mc
```

```{r}
w_inst <- which(allinstscan[,1] == motifmatrix[1,2]) #instances pertaining to specific motif
instances_specificTF <- allinstscan[w_inst,]
inst_bed <- instances_specificTF[,c(2,3,4)]

inst_bed <- cbind(inst_bed, motifmatrix[1,1], instances_specificTF[,6], "+") 
#region as wide as a motif 
motif_width <- as.numeric(inst_bed[,3]) - as.numeric(inst_bed[,2])
inst_bed[,2] <- as.numeric(inst_bed[,2]) + floor(motif_width/2)
inst_bed[,3] <- as.numeric(inst_bed[,2]) + 1

#inst_bed[,3] <- as.numeric(inst_bed[,3])#previous version of impact: +(windowsize-10)/2
#inst_bed[,2] <- as.numeric(inst_bed[,2])#previous version of impact: -(windowsize-10)/2
inst_bed <- unique(inst_bed)
colnames(inst_bed) <- c('chr','start','end','id','score','strand') 
inst_bed_Granges <- with(inst_bed, GRanges(chr, IRanges(start,end), strand, score, id = id)) 
inst_bed_Granges
```

```{r}
int_1 <- GenomicRanges::intersect(inst_bed_Granges, get(motifmatrix[1,3]))
int_2 <- GenomicRanges::intersect(inst_bed_Granges, Granges_obj_mc)
```

Also the same as below (...)
```{r}
overlaps <- GenomicRanges::findOverlaps(inst_bed_Granges, get(motifmatrix[1,3]))
overlaps ; inst_bed_Granges[queryHits(overlaps), ] ; get(motifmatrix[1,3])[subjectHits(overlaps), ]
```


Continue...

```{r}
ms_1 <- match(start(int_1)-1, inst_bed$start)
me_1 <- match(end(int_1), inst_bed$end)
a <- c(ms_1,me_1)
a <- unique(a[is.na(a) == F])
```

```{r}
ms_2 <- match(start(int_2)-1, inst_bed$start)
me_2 <- match(end(int_2), inst_bed$end)
b <- c(ms_2,me_2)
b <- unique(b[is.na(b) == F])
ab <- unique(c(a,b))
ab <- ab[!is.na(ab)]
ab
```

```{r}
if (length(ab) > 0){
    noChIP <- inst_bed[-ab,] #good negative peaks
}else{
    noChIP <- inst_bed
}

dim(noChIP)
```

\newpage
## My approach

Remember I have the `chip_granges` and the top 15000 predicted motifs
```{r}
chip_granges
```

```{r}
pred_motifs_granges <- with(instscan, GRanges(V2, IRanges(V3,V4), strand=V5, score=V6))
pred_motifs_granges
```

My approach is to simply overlap them
```{r}
overlaps <- GenomicRanges::findOverlaps(query=chip_granges, subject=pred_motifs_granges,type='any')
overlaps
```

```{r}
chip_granges[queryHits(overlaps), ] ; pred_motifs_granges[subjectHits(overlaps), ]
```

I am getting, qualitatively, the same result. 

But if I do it my way, I will choose just this region as a bound region. 

And these remaining regions as my unbound regions
```{r}
pred_motifs_granges[-subjectHits(overlaps), ]
```
