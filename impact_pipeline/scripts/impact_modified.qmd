---
title: "IMPACT vs. PMIntersect (Peak Motif Intersect) approaches to defining bound and unbound regions"
author: "Temi"
date: 'Wednesday Dec 14 2022'
format: 
  pdf: 
    toc: true
    number-sections: true
    code-line-numbers: true
---
Kawakami, intersected, using IMPACT to define positive and negative sets

```{r}
library(glue)
library(rjson)
library(data.table)
library(GenomicRanges)
library(parallel)
library(tidyverse)
```

```{r}
project_dir <- '/lus/grand/projects/covid-ct/imlab/users/temi/projects/TFXcan/impact_pipeline'
#setwd(project_dir)
```

```{r}
output_dir <- glue('{project_dir}/explore_impact')
id <- 'kawakami'
TF <- 'FOXA1'
cell_line <- 'LuCaP'
homer_dir <- glue('/lus/grand/projects/covid-ct/imlab/users/temi/software/homer') #glue('/home/temi/miniconda3/envs/homer-env/share/homer') # /home/temi/miniconda3/envs/homer-env/share/homer/bin/findMotifsGenome.pl
common_dir <- glue('{project_dir}/processed_data/impact_files/common_files/{TF}')
```

Directories and e.t.c.
### Step 1: Use Homer to predict genome-wide motifs and select a threshold

Here I select those with a score >= 9
```{r}
genome_wide_predicted_motifs <- data.table::fread(glue('{common_dir}/{TF}_{cell_line}_scanMotifsGenomewide_sort.txt'))
dim(genome_wide_predicted_motifs) ; genome_wide_predicted_motifs[1:5, ]
```

```{r}
threshold <- 9
predicted_motifs <- genome_wide_predicted_motifs[genome_wide_predicted_motifs$V6 >= threshold, ]
dim(predicted_motifs) ; predicted_motifs[1:5, ]
```

### Step 2: Prepare the peak files

make the granges appropriate for impact
```{r}
chip_file <- glue('{project_dir}/processed_data/impact_files/kawakami-human/bedtools-intersected-regions/FOXA1_intersected_files.bed')
chip_dt <- data.table::fread(chip_file, select=c(1:5))
chip_dt[1:5, ]
```


Select 200 peaks to test with (These are randomly selected peaks)
```{r}
# shuffle or randomize the peaks
# set.seed(2022)
# chip_dt <- chip_dt[sample(1:nrow(chip_dt), nrow(chip_dt), replace=F), ]
# nrow(chip_dt)
```
```{r}
# convert into a granges object
chip_granges <- with(chip_dt, GenomicRanges::GRanges(chrom, IRanges(start, end), strand='*', num=num, list=list))
chip_granges
```
```{r}
chip_bed <- cbind(as.character(seqnames(chip_granges)), start(chip_granges), end(chip_granges), paste0("peak", seq(1,length(chip_granges),1)), 0, "+")
write.table(chip_bed, glue("{output_dir}/{id}_{TF}_{cell_line}_train_df.txt"), sep = "\t", quote = F, row.names = FALSE, col.names = FALSE)
chip_bed[1:5, ]
```

### Step 3: Make the motif file appropriate
Essentially, add in the threshold

```{r}
motif_file <- data.table::fread(glue('{common_dir}/{TF}_{cell_line}.motif'), header=F)
motif_file[1,3] <- threshold
motif_file
```

```{r}
write.table(motif_file, glue('{common_dir}/{TF}_{cell_line}_threshold.motif'), sep='\t', row.names=F, col.names=F, quote=F)
```

### Step 4: Run findMotifsGenome.pl using the new motif file and the TF chIP peaks 

```{r}
find_motifs_pbs <- glue("{project_dir}/scripts/find_motifs_genome.sh")
file.exists(find_motifs_pbs)
```

```{r}
homer_script <- glue('{homer_dir}/bin/findMotifsGenome.pl')
file.exists(homer_script)
```

```{r}
# cmd <- glue('perl {homer_dir}/bin/findMotifsGenome.pl {output_dir}/{id}_{TF}_{cell_line}_train_df.txt {homer_dir}/data/genomes/hg19 {output_dir}/homer_output/ -size given -find {common_dir}/{TF}_{cell_line}_threshold.motif > {output_dir}/{id}_{TF}_{cell_line}_findinstances.txt')
# system(cmd)
```

```{r, eval=F}
cmd <- glue("qsub -v find_motifs_script={homer_script},peaks={output_dir}/{id}_{TF}_{cell_line}_train_df.txt,genome={homer_dir}/data/genomes/hg19,homer_output={output_dir}/homer_output/,size=given,motif_file={common_dir}/{TF}_{cell_line}_threshold.motif,output={output_dir}/{id}_{TF}_{cell_line}_findinstances.txt {find_motifs_pbs}")
cmd
```

```{r}
system(cmd)
```

```{r}
system('qstat -u temi')
```


```{r}
# This is another way to do the same thing
# cmd <- glue('perl {homer_dir}/bin/annotatePeaks.pl {output_dir}/{id}_{TF}_{cell_line}_train_df.txt {homer_dir}/data/genomes/hg19 -size given -m {common_dir}/{TF}_{cell_line}.motif > {output_dir}/annotated_{id}_{TF}_{cell_line}_findinstances.txt')
# system(cmd)
```

```{r}
#data.table::fread(glue('{output_dir}/annotated_{id}_{TF}_{cell_line}_findinstances.txt'))
```

### Step 5: Define positive regions

We read in all the files we need
```{r}
motif_instances <- read.table(glue('{output_dir}/{id}_{TF}_{cell_line}_findinstances.txt'), sep = "\t", header = T, stringsAsFactors = FALSE)
motif_instances |> head()
```

```{r}
chip_regions <- read.table(glue('{output_dir}/{id}_{TF}_{cell_line}_train_df.txt'), sep='\t', header=F, stringsAsFactors=F) 
motif_library <- read.table(glue('{common_dir}/{TF}_{cell_line}_motif_threshold_info.txt'), sep = "\t", header = F, stringsAsFactors = FALSE)
motif_library[1,2] <- threshold

colnames(chip_regions) <- c("seqnames","starts","ends","names","scores","strands")
#select ChIP peaks with a matching motif under them.
chip_regions_full <- chip_regions
m <- match(chip_regions[,4], motif_instances[,1]) # what chips are in motifs data?
chip_regions <- chip_regions_full[which(is.na(m) == F),]
```

```{r}
# chip_regions_newpeaks <- matrix(0,nrow(chip_regions),6) #dummy var number of rows 

# for (i in 1:nrow(chip_regions)){
#     print(paste0("row ", i, " of ", nrow(chip_regions)))
#     w <- which(motif_instances$PositionID == chip_regions[i,4]) #match peakID, gauranteed to have a match 

#     #only choose 1 motif, take the one with the top score
#     w1 <- w[match(max(motif_instances$MotifScore[w]), motif_instances$MotifScore[w])]

#     if (motif_instances$Strand[w1] == "+"){
#         centerpeak <- motif_instances$Offset[w1] + floor(0.5*(nchar(motif_instances$Sequence[w1]))) #this is relative to start 
#     }else{
#         centerpeak <- motif_instances$Offset[w1] - floor(0.5*(nchar(motif_instances$Sequence[w1])))
#     }
#     newstart <- chip_regions$starts[i]+centerpeak #previous version of impact -windowsize/2 #establish left bound of peaks
#     newend <- newstart + 1 #previous version of impact +windowsize #establish right bound of peaks 
#     chip_regions_newpeaks[i,1] <- as.character(chip_regions$seqnames[i])
#     chip_regions_newpeaks[i,2] <- newstart
#     chip_regions_newpeaks[i,3] <- newend
#     chip_regions_newpeaks[i,4] <- as.character(chip_regions$names[i]) #preserve old information
#     chip_regions_newpeaks[i,5] <- as.character(chip_regions$scores[i])
#     chip_regions_newpeaks[i,6] <- as.character(chip_regions$strands[i])
# }

# write.table(chip_regions_newpeaks, glue("{output_dir}/{id}_{TF}_{cell_line}_train_df_newpeaks.txt"), sep = "\t", quote = F, row.names = FALSE, col.names = FALSE)
# chip_regions_newpeaks[1:5, ]
```

```{r}
library(pbapply)
```


```{r}
# which column is starts
starts_col <- which(colnames(chip_regions) == 'starts')
ends_col <- which(colnames(chip_regions) == 'ends')

chip_regions_newpeaks <- pbapply::pbapply(chip_regions, 1, function(each_row){
    each_row <- as.list(each_row)

    w <- which(motif_instances$PositionID == each_row[[4]]) #match peakID, gauranteed to have a match 

    #only choose 1 motif, take the one with the top score
    w1 <- w[match(max(motif_instances$MotifScore[w]), motif_instances$MotifScore[w])]

    if (motif_instances$Strand[w1] == "+"){
        centerpeak <- motif_instances$Offset[w1] + floor(0.5*(nchar(motif_instances$Sequence[w1]))) #this is relative to start 
    }else{
        centerpeak <- motif_instances$Offset[w1] - floor(0.5*(nchar(motif_instances$Sequence[w1])))
    }
    #print(each_row[[starts_col]])
    each_row[[starts_col]] <- as.numeric(each_row[[starts_col]]) + centerpeak #previous version of impact -windowsize/2 #establish left bound of peaks
    each_row[[ends_col]] <- each_row[[starts_col]] + 1

    return(c(each_row |> unlist()))

}) |> t()
```

```{r}
write.table(chip_regions_newpeaks, glue("{output_dir}/{id}_{TF}_{cell_line}_train_df_newpeaks.txt"), sep = "\t", quote = F, row.names = FALSE, col.names = FALSE)
chip_regions_newpeaks[1:5, ]
```

```{r}
chip_regions_newpeaks <- read.table(glue('{output_dir}/{id}_{TF}_{cell_line}_train_df_newpeaks.txt'), sep = "\t", header = F, stringsAsFactors = FALSE)

chip_regions_newpeaks_realdf <- data.frame(seqnames=chip_regions_newpeaks[,1],
                                    starts=as.numeric(chip_regions_newpeaks[,2]),
                                    ends=as.numeric(chip_regions_newpeaks[,3]),
                                    names=chip_regions_newpeaks[,4],
                                    scores=0,
                                    strands="+")

set.seed(2022)
s <- sample(seq(1,nrow(chip_regions_newpeaks_realdf),1), nrow(chip_regions_newpeaks_realdf),replace = F)
s[1:5]
```

```{r}
chip_regions_newpeaks_realdf <- chip_regions_newpeaks_realdf[s,]
#put training and test together! 
#use partition function later to make it easier to sample many times! 
train_test_peaks <- unique(chip_regions_newpeaks_realdf)
colnames(train_test_peaks) <- c("seqnames","starts","ends","names","scores","strands")

#clean up 
if (length(which(train_test_peaks$start < 0)) > 0){
    train_test_peaks$start[which(train_test_peaks$start < 0)] <- 0
}

t <- train_test_peaks[,3]-train_test_peaks[,2]
w <- which(t %% 2 != 0) #odd
if (length(w) > 0){
    train_test_peaks[w,3] <- train_test_peaks[w,3] + 1
}

w1 <- which(train_test_peaks$chr == "chrM")
w2 <- which(nchar(train_test_peaks$chr) > 5)
if (length(c(w1,w2)) > 0){
    train_test_peaks <- train_test_peaks[-c(w1,w2),]
}

write.table(train_test_peaks, glue("{output_dir}/{id}_{TF}_{cell_line}_train_test_positive_bed.txt"), sep = "\t", quote = F, row.names = FALSE, col.names = FALSE)
train_test_peaks[1:5, ]
```

Check that these regions are non-overlapping: can reduce the granges object and check that the lengths don't differ
```{r}
#
pos_granges <- with(train_test_peaks, GenomicRanges::GRanges(seqnames, IRanges(starts,ends), strand=strands, score=scores, id = names))
pos_granges
```

```{r}
stopifnot(length(GenomicRanges::reduce(pos_granges)) == length(pos_granges))
```


### Step 6: Define negative regions

Start with the already define positive and negative sets instead
```{r}
#train_df_newpeaks <- read.table(glue("{output_dir}/{id}_{TF}_{cell_line}_train_df_newpeaks.txt"), sep = "\t", header = F, stringsAsFactors = FALSE)
train_df_newpeaks <- train_test_peaks
MotifThreshold <- motif_library #read.table(glue("{common_dir}/{TF}_{cell_line}_motif_threshold_info.txt"), sep = "\t", header = F, stringsAsFactors = FALSE)
```

```{r}
motifs <- MotifThreshold[1,1]
instscan <- predicted_motifs #read.table(glue("{common_dir}/{TF}_{cell_line}_scanMotifsGenomewide_sort_15000.txt"), sep = "\t", header = F, stringsAsFactors = FALSE)
instscan[1:5, ]
```

```{r}
instscan <- instscan[order(instscan[,6], decreasing = T), ]   
train_df <- read.table(glue("{output_dir}/{id}_{TF}_{cell_line}_train_df.txt"), sep = "\t", header = F, stringsAsFactors = FALSE) 
colnames(train_df) <- c('chr','start','end','id','score','strand') #score may be number of reads
Granges <- with(train_df, GRanges(chr, IRanges(start,end), strand, score, id = id))
assign(paste0(motifs,"_Granges"),Granges)
```

```{r}
allinstscan <- instscan |> as.data.frame()
sapply_instscan <- sapply(1:nrow(allinstscan), function(x){
    #print(x)
    strsplit(allinstscan[x,1], "-")[[1]][1]
})
allinstscan[,1] <- sapply_instscan
allinstscan[,6] <- allinstscan[,6]/MotifThreshold[1,2]
allinstscan[1:5, ]
```

```{r}
w <- which(allinstscan[,6] < 1) 
if(length(w)>0){allinstscan <- allinstscan[-w,]}

motifmatrix <- matrix(0,nrow(MotifThreshold),3)
motifmatrix[,1] <- motifs 
motifmatrix[,2] <- motifs
motifmatrix[,3] <- paste0(motifs,"_Granges")
motifmatrix
```

```{r}
print(paste0("working on ",motifmatrix[1,1]))
w_mcp <- which(train_df_newpeaks[,5] == motifmatrix[1,2]) #motifcentered peaks
motifcentered_specificTF <- train_df_newpeaks[w_mcp,]
colnames(motifcentered_specificTF) <- c('chr','start','end','id','score','strand') 
Granges_obj_mc <- with(motifcentered_specificTF, GRanges(chr, IRanges(start,end), strand, score, id = id))
Granges_obj_mc
```

```{r}
w_inst <- which(allinstscan[,1] == motifmatrix[1,2]) #instances pertaining to specific motif
instances_specificTF <- allinstscan[w_inst,]
inst_bed <- instances_specificTF[,c(2,3,4)]

inst_bed <- cbind(inst_bed, motifmatrix[1,1], instances_specificTF[,6], "+") 
#region as wide as a motif 
motif_width <- as.numeric(inst_bed[,3]) - as.numeric(inst_bed[,2])
inst_bed[,2] <- as.numeric(inst_bed[,2]) + floor(motif_width/2)
inst_bed[,3] <- as.numeric(inst_bed[,2]) + 1

#inst_bed[,3] <- as.numeric(inst_bed[,3])#previous version of impact: +(windowsize-10)/2
#inst_bed[,2] <- as.numeric(inst_bed[,2])#previous version of impact: -(windowsize-10)/2
inst_bed <- unique(inst_bed)
colnames(inst_bed) <- c('chr','start','end','id','score','strand') 
inst_bed_Granges <- with(inst_bed, GRanges(chr, IRanges(start,end), strand, score, id = id)) 
inst_bed_Granges
```

```{r}
int_1 <- GenomicRanges::intersect(inst_bed_Granges, get(motifmatrix[1,3]))
int_2 <- GenomicRanges::intersect(inst_bed_Granges, Granges_obj_mc)
```

Also the same as below (...)
```{r}
overlaps <- GenomicRanges::findOverlaps(inst_bed_Granges, get(motifmatrix[1,3]))
overlaps ; inst_bed_Granges[queryHits(overlaps), ] ; get(motifmatrix[1,3])[subjectHits(overlaps), ]
```


Continue...

```{r}
ms_1 <- match(start(int_1)-1, inst_bed$start)
me_1 <- match(end(int_1), inst_bed$end)
a <- c(ms_1,me_1)
a <- unique(a[is.na(a) == F])
```

```{r}
ms_2 <- match(start(int_2)-1, inst_bed$start)
me_2 <- match(end(int_2), inst_bed$end)
b <- c(ms_2,me_2)
b <- unique(b[is.na(b) == F])
ab <- unique(c(a,b))
ab <- ab[!is.na(ab)]
ab[1:5]
```

```{r}
if (length(ab) > 0){
    noChIP <- inst_bed[-ab,] #good negative peaks
}else{
    noChIP <- inst_bed
}

dim(noChIP)
```

```{r}
noChIP$end <- noChIP$end + 1
noChIP[1:5, ]
```


### Step 7: Check that there are no overlaps between positives and negatives

```{r}
pos_granges <- with(train_df_newpeaks, GenomicRanges::GRanges(seqnames, IRanges(starts,ends), strand=strands, score=scores, id = names))
pos_granges
```

```{r}
neg_granges <- with(noChIP, GenomicRanges::GRanges(chr, IRanges(start,end), strand=strand, score=score, id = id))
neg_granges
```

```{r}
int_3 <- GenomicRanges::intersect(pos_granges, neg_granges)
int_3
```
```{r}
int_3 <- GenomicRanges::intersect(neg_granges, pos_granges)
int_3
```

Take out the ones that are overlapping
```{r}
overlaps <- GenomicRanges::findOverlaps(pos_granges, neg_granges)
overlaps ; pos_granges[queryHits(overlaps), ] ; neg_granges[subjectHits(overlaps), ]
```

```{r}
pos_granges <- pos_granges[-queryHits(overlaps), ]
neg_granges <- neg_granges[-subjectHits(overlaps), ]
```

Check that they are not overlapping
```{r}
pos_granges <- GenomicRanges::reduce(pos_granges)
neg_granges <- GenomicRanges::reduce(neg_granges)
```

```{r}
stopifnot(any(width(pos_granges) != 3) == F)
```

```{r}
stopifnot(any(width(neg_granges) != 3) == F)
```

### Step 8: Modify and save the files

- Ensure that you only have valid chromosomes
- Get the binding counts information (this should be done only for the positive sets)
- Save only the chr, start, end, class (bound or not), and binding counts

```{r}
# valid chromosomes
valid_chromosomes <- paste0('chr', c(1:22, 'X'))
valid_chromosomes
```

- Select valid chromosomes
```{r}
temp_pos_granges <- pos_granges[seqnames(pos_granges) %in% valid_chromosomes]
```
- overlap with the binding counts information
Remember that you have `chip_granges`
```{r}
bc_overlaps <- GenomicRanges::findOverlaps(temp_pos_granges, chip_granges)
bc_overlaps
```

```{r}
positive_bc <- chip_granges[subjectHits(bc_overlaps), ]
positive_bc
```

```{r}
temp_pos_granges <- temp_pos_granges[queryHits(bc_overlaps), ]
temp_pos_granges
```

```{r}
stopifnot(length(temp_pos_granges) == length(positive_bc))
```

```{r}
binding_counts <- mcols(positive_bc)[, 'num']
length(binding_counts)
```

```{r}
mcols(temp_pos_granges)$class <- 1
mcols(temp_pos_granges)$binding_counts <- binding_counts
temp_pos_granges
```

```{r}
positive_set <- as.data.frame(temp_pos_granges)
names(positive_set)[1] <- 'chr'
positive_set <- positive_set[, c('chr', 'start', 'end', 'class', 'binding_counts')]
positive_set |> head()
```

Negative set

```{r}
temp_neg_granges <- neg_granges[seqnames(neg_granges) %in% valid_chromosomes]
temp_neg_granges
```

```{r}
mcols(temp_neg_granges)$class <- 0
mcols(temp_neg_granges)$binding_counts <- 0
temp_neg_granges
```

```{r}
negative_set <- as.data.frame(temp_neg_granges)
names(negative_set)[1] <- 'chr'
negative_set <- negative_set[, c('chr', 'start', 'end', 'class', 'binding_counts')]
negative_set |> head()
```

```{r}
training_set <- rbind(positive_set, negative_set)
training_set <- training_set[sample(1:nrow(training_set), nrow(training_set), replace=F), ]
training_set |> dim() ; training_set |> head()
```


Save the files
```{r}
todays_date <- Sys.Date()
save_dir <- glue('{project_dir}/defined_regions/kawakami/regions_{todays_date}')
if(!dir.exists(save_dir)){
    dir.create(save_dir, recursive=T)
}
```

```{r}
data.table::fwrite(training_set, glue('{save_dir}/{id}_{TF}_{nrow(training_set)}.txt'), quote=F, row.names=F, col.names=T)
```

### Plotting

```{r}
ps <- positive_set %>%
    dplyr::group_by(chr) %>%
    dplyr::summarise(cnts=n()) %>%
    as.data.frame()

ns <- negative_set %>%
    dplyr::group_by(chr) %>%
    dplyr::summarise(cnts=n()) %>%
    as.data.frame() 

pns <- merge(ps, ns, by='chr', suffixes=c('_positive', '_negative'))
pns
```

```{r}
barplot(pns[, 2:3] |> t(), beside=T, names.arg=pns[, 1])
```
Nice!


\newpage
## My approach

Remember I have the `chip_granges` and the top 15000 predicted motifs
```{r}
chip_granges # chip peaks
```

```{r}
pred_motifs_granges <- with(instscan, GRanges(V2, IRanges(V3,V4), strand=V5, score=V6))
pred_motifs_granges
```

My approach is to simply overlap them
```{r}
overlaps <- GenomicRanges::findOverlaps(query=chip_granges, subject=pred_motifs_granges,type='any')
overlaps
```

```{r}
chip_granges[queryHits(overlaps), ] ; pred_motifs_granges[subjectHits(overlaps), ]
```

I am getting, qualitatively, the same result. 

But if I do it my way, I will choose just this region as a bound region. 

And these remaining regions as my unbound regions
```{r}
pred_motifs_granges[-subjectHits(overlaps), ]
```
